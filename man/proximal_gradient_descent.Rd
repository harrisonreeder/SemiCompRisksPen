% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proximal_gradient_descent.R
\name{proximal_gradient_descent}
\alias{proximal_gradient_descent}
\title{Proximal Gradient Descent Algorithm}
\usage{
proximal_gradient_descent(
  para,
  y1,
  y2,
  delta1,
  delta2,
  Xmat1 = matrix(nrow(length(y1)), ncol = 0),
  Xmat2 = matrix(nrow(length(y1)), ncol = 0),
  Xmat3 = matrix(nrow(length(y1)), ncol = 0),
  hazard,
  frailty,
  model,
  basis1 = NULL,
  basis2 = NULL,
  basis3 = NULL,
  basis3_y1 = NULL,
  dbasis1 = NULL,
  dbasis2 = NULL,
  dbasis3 = NULL,
  penalty,
  lambda,
  a,
  penalty_fusedcoef,
  lambda_fusedcoef,
  penalty_fusedbaseline,
  lambda_fusedbaseline,
  penweights_list,
  mu_smooth_fused,
  step_size_init = 1,
  step_size_min = 1e-06,
  step_size_max = 1e+06,
  step_size_scale = 1/2,
  ball_R = Inf,
  maxit = 300,
  select_tol = 1e-04,
  conv_crit = "nll_pen_change",
  conv_tol = if (lambda > 0) lambda/4 else 1e-06,
  verbose
)
}
\arguments{
\item{para}{A numeric vector of parameters, arranged as follows:
the first \eqn{k_1+k_2+k_3} elements correspond to the baseline hazard parameters,
then the \eqn{k_1+k_2+k_3+1} element corresponds to the gamma frailty log-variance parameter,
then the last\eqn{q_1+q_2+q_3} elements correspond with the regression parameters.}

\item{y1, y2}{Numeric vectors of length \eqn{n} with (possibly censored) non-terminal and terminal event times}

\item{delta1, delta2}{Numeric vectors of length \eqn{n}  with indicators of 1 if the event was observed and 0 otherwise}

\item{Xmat1, Xmat2, Xmat3}{Numeric matrices with \eqn{n} rows and \eqn{q_1,q_2,q_3} columns containing covariates.}

\item{hazard}{String specifying the form of the baseline hazard.}

\item{frailty}{Boolean indicating whether a gamma distributed subject-specific frailty should
be included. Currently this must be set to TRUE.}

\item{model}{String specifying the transition assumption}

\item{basis1, basis2, basis3, basis3_y1}{Numeric matrices with \eqn{n} rows and \eqn{k_1,k_2,k_3} columns
with piecewise/spline basis function values at the corresponding \code{y1} and \code{y2} values.
Under semi-Markov model, basis3 represents basis derived from \eqn{y_2-y_1} and \code{basis3_y1} is unused,
while under Markov model, basis3 represents basis derived from \eqn{y_2} and \code{basis3_y1} is from \eqn{y_1}
Not used under Weibull model.}

\item{dbasis1, dbasis2, dbasis3}{Numeric matrices with \eqn{n} rows and \eqn{k_1,k_2,k_3} columns
with piecewise/spline basis function derivative values at the corresponding \code{y1} and \code{y2} values.
Used only under Royston-Parmar model.}

\item{penalty}{A string value indicating the form of parameterwise penalty
to apply. "lasso", "scad", and "mcp" are the options.}

\item{lambda}{The strength of the parameterwise penalty. Either a single non-negative numeric value
for all three transitions, or a length 3 vector with elements corresponding to the three transitions.}

\item{a}{For two-parameter penalty functions (e.g., scad and mcp), the second parameter.}

\item{penalty_fusedcoef}{A string value indicating the form of the fusion penalty to apply
to the regression parameters. "none" and "fusedlasso" are the options.}

\item{lambda_fusedcoef}{The strength of the fusion penalty on the regression parameters.
Either a single non-negative numeric value
for all three transitions, or a length 3 vector with elements corresponding to the three transitions.}

\item{penalty_fusedbaseline}{A string value indicating the form of the fusion penalty to apply
to the baseline hazard parameters. "none" and "fusedlasso" are the options.}

\item{lambda_fusedbaseline}{The strength of the fusion penalty on the regression parameters.
Either a single non-negative numeric value
for all three transitions, or a length 3 vector with elements corresponding to the three transitions.}

\item{penweights_list}{A list of numeric vectors representing weights for each
penalty term (e.g., for adaptive lasso.) Elements of the list should be indexed by the
names "coef1", "coef2", "coef3", "fusedcoef12", "fusedcoef13", "fusedcoef23", "fusedbaseline12", "fusedbaseline13", and "fusedbaseline23"}

\item{mu_smooth_fused}{A non-negative numeric value for the Nesterov smoothing parameter applied to the fusion penalty.}

\item{step_size_init}{Positive numeric value for the initial step size.}

\item{step_size_min}{Positive numeric value for the minimum allowable step size to allow during backtracking.}

\item{step_size_max}{Positive numeric value for the maximum allowable step size to allow by size increase at each iteration.}

\item{step_size_scale}{Positive numeric value for the multiplicative change in step size at each step of backtracking.}

\item{ball_R}{Positive numeric value for \eqn{l_2} ball constraint around the origin for the regression parameters.
Typically set to \code{Inf} indicating no constraint, otherwise equivalent to an extra \eqn{l_2} penalty.}

\item{maxit}{Positive integer maximum number of iterations.}

\item{select_tol}{Positive numeric value for thresholding estimates to be equal to zero.}

\item{conv_crit}{String (possibly vector) giving the convergence criterion.}

\item{conv_tol}{Positive numeric value giving the convergence tolerance for the chosen criterion.}

\item{verbose}{Numeric indicating the amount of iteration information should be printed to the user.
Higher numbers provide more detailed information to user, but will slow down the algorithm.}
}
\value{
A list.
}
\description{
This function runs a proximal gradient descent algorithm with backtracking similar to that presented by
Wang et al. (2014).
}
